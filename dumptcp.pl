#!/usr/bin/perl
##
## Mario Arturo Perez Rangel
##
## Programa que captura paquetes de tcp/ip y muestra la informacion de las
## cabeceras.
## Muestra paquetes que contengan ip con udp, tcp e icmp. Tambien muestra los
## encabezados del paquete de ethernet con la opcion -e.
## Se utiliza el modulo Net::Pcap para la diseccion de paquetes.
use strict;
use IO::Interface qw (:flags);
use Net::Pcap;
use Getopt::Long;

my ($capture, $fname, $dev, $error);
my $filter;
my $filter_str = "";

# Varios de los tipos de mensajes icmp con sus respectivos codigos
my %icmptypes = (0 => 'echo reply',
		 3 => ['network unreachable', 'host unreachable',
		       'protocol unreachable', 'port unreachable',
		       'fragmentation required', 'source route failed',
		       'dest. network unknown', 'destination host unknown',
		       'source host isolated', 'net administratively prohibited',
		       'host administratively prohibited',
		       'network unreachable for tos',
		       'host unreachable for tos',
		       'communication admin. prohibited'],
		 4 => 'source quench',
		 5 => ['network redirect', 'host redirect',
		       'tos & network redirect', 'tos & host redirect'],
		 8 => 'echo request',
		 9 => 'router advertisement',
		 11 => ['time to live exceeded in transit',
			'fragment reassembly time exceeded'],
		 12 => ['parameter prob. pointer indicated the error',
			'missing a required option',
			'bad length'],
		 13 => 'timestamp',
		 14 => 'timestamp reply',
		 15 => 'information request',
		 16 => 'information reply',
		 17 => 'address mask request',
		 18 => 'address mask reply',
		 30 => 'traceroute'
    );

# Numero y nombre de protocolo de internet asi como la funcion
# que muestra el contenido del respectivo paquete
my %ipp = ( 1  => ['TCP', \&dump_icmp4_pkt],
	    6  => ['TCP', \&dump_tcp4_pkt],
            17 => ['UDP', \&dump_udp4_pkt]);

my $edump;
GetOptions ('edump|e' => \$edump,
            'i=s' => \$dev);

if (!$dev) { # Buscamos una interfaz para obtener paquetes
    $dev = Net::Pcap::lookupdev(\$error);
    if ($error) {
	print STDERR "Error: $error\n";
    } else {
	print STDERR "Dispositivo: $dev\n";
    }
}
# Obtiene la direccion ip de este equipo
my $local_ip = get_local_ip_address();


# Obtenemos una sesion de captura
$capture = Net::Pcap::open_live ($dev, 3600, 1, 0, \$error);

if (!defined($capture)) {
    print STDERR "Error: $error\n";
}

# Si tenemos un filtro de captura lo compilamos
if (Net::Pcap::compile ($capture, \$filter, $filter_str, 0, "255.255.255.0") == -1) {
    print STDERR "Error:", Net::Pcap::geterr($capture) ,"\n";
}

# Aplica el filtro ya compilado en $filter
Net::Pcap::setfilter ($capture, $filter);

#
# Se pone a la escucha, el segundo argumento indica
# que se quede escuchando por siempre. Por cada paquete se llama
# a la funcion dump_pkt
Net::Pcap::loop ($capture, -1, \&dump_pkt, "root",);
Net::Pcap::close ($capture);

##
## Procesa el paquete capturado.
## Muestra las direcciones ethernet si lo pide el usuario.
##
sub dump_pkt {
    my($user_data, $hdr, $pkt) = @_;
    my $frame_type;

    # Revisa el tipo de frame contenido en el paquete
    $frame_type = unpack("n", substr($pkt,12,2));
    if ($edump) {   # Muestra las direcciones ethernet
	my ($ether_src, $ether_dst, $i) = ('', '', 0);

	$ether_src = join ':', unpack("H2H2H2H2H2H2", substr($pkt, 0, 6));
	$ether_dst = join ':', unpack("H2H2H2H2H2H2", substr($pkt, 6, 6));
	printf "%s, %s (0x%04x)\n", $ether_src, $ether_dst, $frame_type;
    }
    if ($frame_type == 0x800) {                    # Trama de IP
	dump_ip_pkt($pkt);
    }
    if ($frame_type == 0x806) {                    # Trama ARP
	dump_arp_pkt($pkt);
    }
    if ($frame_type == 0x8035) {                   # Trama RARP
	dump_rarp_pkt($pkt);
    }
}

##
## Muestra las cabeceras de la trama de ip.
## Recibe: el paquete
## Entrega: nada.
sub dump_ip_pkt {
    my $pkt = shift @_;
    my ($ip_ver, $ip_hlen, $ip_tos, $ip_tlen, $ip_id, $ip_flags);
    my ($ip_off, $ip_ttl, $ip_proto, $ip_hchksum, $ip_src, $ip_dst);
    my ($sport, $dport);

    # Disecciona el paquete y obtiene las cabeceras de ip
    ($ip_ver, $ip_tos, $ip_tlen, $ip_id, $ip_flags, $ip_ttl,
     $ip_proto, $ip_hchksum) = unpack("C2n3C2n", substr($pkt, 14, 12));
    $ip_hlen = ($ip_ver & 0x0F) << 2;
    $ip_ver = $ip_ver >> 4;
    $ip_off = $ip_flags & 0x1FFF;
    $ip_flags = $ip_flags >> 13;
    $ip_src = join '.', unpack ("C4", substr ($pkt, 26, 4));
    $ip_dst = join '.', unpack ("C4", substr ($pkt, 30, 4));
    ($sport, $dport) = unpack ("n2", substr ($pkt, 34, 4));
    # Presenta informacion del paquete
    if ($ip_ver == 4) {
	printf "IPv%d (tos %x, ttl %d, id %d, ",
	    $ip_ver, $ip_tos, $ip_ttl, $ip_id, $ip_flags;
	printf ("defrag, off %d, ",  $ip_off) if ($ip_flags & 0x01);
	print "no defrag, " if ($ip_flags & 0x02);
	printf "proto %s (%d), length %d)\n",
	    $ipp{$ip_proto}[0], $ip_proto, $ip_tlen;
	if (($ip_proto == 6) or ($ip_proto == 17)) {
	    printf "%s.%d -> %s.%d. ", $ip_src,$sport, $ip_dst, $dport;
	} else {
	    printf "%s -> %s. ", $ip_src,$ip_dst;
	}
	$ipp{$ip_proto}[1]($pkt, $ip_tlen, $ip_hlen) if ($ipp{$ip_proto}[1]);
    }
}

##
## Muestra las cabeceras del segmento de tcp.
## Recibe: el paquete.
## Entrega: nada
sub dump_tcp4_pkt {
    my ($pkt, $ip_tlen, $ip_hlen) = @_;
    my ($tcp_seq, $tcp_ack, $tcp_hlen);
    my ($tcp_flags, $tcp_ws, $tcp_chksum, $tcp_urg);

    # Obtiene las cabeceras tcp del paquete
    ($tcp_seq, $tcp_ack, $tcp_hlen, $tcp_flags, $tcp_ws,
     $tcp_chksum, $tcp_urg) = unpack ("N2C2n3", substr($pkt, 14+$ip_hlen+4, 16));
    $tcp_hlen = ($tcp_hlen & 0xF0) >> 2;
    # Presenta el contenido
    print "TCP ";
    printf ("urg %d, ", $tcp_urg) if ($tcp_flags & 0x20);
    print "push, " if ($tcp_flags & 0x08);
    print "rst, " if ($tcp_flags & 0x04);
    print "syn, " if ($tcp_flags & 0x02);
    print "fin, " if ($tcp_flags & 0x01);
    printf "checksum 0x%x, seq %d, ack %d, ws %d, length %d\n",
	$tcp_chksum, $tcp_seq, $tcp_ack, $tcp_ws, $ip_tlen-$ip_hlen-$tcp_hlen;
}

##
## Muestra las cabeceras de la trama de udp.
## Recibe: el paquete.
## Entrega: nada
sub dump_udp4_pkt {
    my ($pkt, $ip_tlen, $ip_hlen) = @_;
    my ($udp_length, $udp_chksum);

    # Obtiene las cabeceras de UDP
    # 14 bytes de cabeceras de ethernet + 20 bytes de cabeceras de IP
    ($udp_length, $udp_chksum) =
	unpack ("n2", substr($pkt, 14+$ip_hlen+4, 4));
    printf "UDP length %d, checksum 0x%x\n", $udp_length, $udp_chksum;
}

##
## Muestra las cabeceras de la trama de icmp.
## Recibe: el paquete.
## Entrega: nada
sub dump_icmp4_pkt {
    my ($pkt, $ip_tlen, $ip_hlen) = @_;
    my ($icmp_type, $icmp_code, $icmp_chksum);
    my ($icmp_id, $icmp_seq);

    # Obtiene las cabeceras del paquete.
    ($icmp_type, $icmp_code, $icmp_chksum) =
	unpack ("C2n3", substr($pkt, 14+$ip_hlen, 8));

    # Presenta las cabeceras
    if ($icmp_type==0) {
	printf "Echo Reply, id 0x%x, sequence %d, ", $icmp_id, $icmp_seq;
    } elsif ($icmp_type==8){
	printf "Echo Request, id 0x%x, sequence %d, ", $icmp_id, $icmp_seq;
    } elsif (($icmp_type==3) or
	     ($icmp_type==5) or
	     ($icmp_type==11) or
	     ($icmp_type==12)){
	print $icmptypes{$icmp_type}[$icmp_code], ', ';
    } else {
	print $icmptypes{$icmp_type}, ', ';
    }
    printf "checksum 0x%x\n", $icmp_chksum;
}

##
## Muestra las cabeceras del paquete arp
## Recibe: El paquete
## Entrega: nada
sub dump_arp_pkt {
    my $pkt = shift @_;
    my ($hw_addr_t, $proto_addr_t, $hw_addr_l, $proto_addr_l, $opcode);
    my ($src_hw_addr, $src_proto_addr, $tgt_hw_addr, $tgt_proto_addr);
    my $sout;

    # Obtiene las campos del paquete
    ($hw_addr_t, $proto_addr_t, $hw_addr_l, $proto_addr_l, $opcode) = 
	unpack ("n2C2n", substr($pkt, 14, 6));
    # Presenta el paquete ARP
    $src_hw_addr    = join ':', unpack("H2H2H2H2H2H2", substr($pkt, 22, 6));
    $src_proto_addr = join '.', unpack("C4", substr($pkt, 28, 4));
    $tgt_hw_addr    = join ':', unpack("H2H2H2H2H2H2", substr($pkt, 32, 6));
    $tgt_proto_addr = join '.', unpack("C4", substr($pkt, 38, 4));
    if ($proto_addr_t == 0x0800) {
	print "ARP (request), " if ($opcode = 1);
	print "ARP (reply), "   if ($opcode = 2);
	printf "%s (%s) -> %s (%s)\n";
    }
}

##
## Muestra las cabeceras del paquete arp
## Recibe: El paquete
## Entrega: nada
sub dump_rarp_pkt {
    my $pkt = shift @_;
    my ($hw_addr_t, $proto_addr_t, $hw_addr_l, $proto_addr_l, $opcode);
    my ($src_hw_addr, $src_proto_addr, $tgt_hw_addr, $tgt_proto_addr);
    my $sout;
    
    # Obtiene las campos del paquete
    ($hw_addr_t, $proto_addr_t, $hw_addr_l, $proto_addr_l, $opcode) = 
	unpack ("n2C2n", substr($pkt, 14, 6));
    # Presenta el paquete ARP
    $src_hw_addr    = join ':', unpack("H2H2H2H2H2H2", substr($pkt, 22, 6));
    $src_proto_addr = join '.', unpack("C4", substr($pkt, 28, 4));
    $tgt_hw_addr    = join ':', unpack("H2H2H2H2H2H2", substr($pkt, 32, 6));
    $tgt_proto_addr = join '.', unpack("C4", substr($pkt, 38, 4));
    if ($proto_addr_t == 0x0800) {
	print "ARP (request reverse), " if ($opcode = 3);
	print "ARP (reply reverse), "   if ($opcode = 4);
	printf "%s (%s) -> %s (%s)\n";
    }
}
# Obtiene la direccion ip de esta maquina
sub get_local_ip_address {
    my ($ifa, $la, $nma) = @_;
    my $socket = IO::Socket::INET->new(
        Proto       => 'udp',
        PeerAddr    => '198.41.0.4', # a.root-servers.net
        PeerPort    => '53', # DNS
    );

    # Consigue del socket los valores necesarios
    $$la  = $socket->sockhost;
    $$nma = $socket->if_netmask($ifa);
}

##
## net_aton convierte una cadena con una direccion ip en un entero
## largo de 4 bytes correspondientes a dicha ip.
## Recibe: cadena con una direccion ip en formato con '.'.
## Regresa: el entero representando la ip
sub net_aton {
    my $ip = shift @_;
    my @oct;

    @oct = split /\./, $ip;
    return ($oct[0]*256**3 + $oct[1]*256*2 + $oct[2]*256 + $oct[3]);
}

