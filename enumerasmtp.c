/*
 * Mario Arturo Perez Rangel
 * 15-03-2017
 *
 */
#include "enumerasmtp.h"

int main(int argc, char *argv[])
{
  int smtp; // Descriptor para la conexion
  char buffer[MAX_DATA_SIZE];  // Texto recibido
  char ip[MAX_DATA_SIZE];
  char user[MAX_DATA_SIZE];
  int codResp;

  if (argc != 3) {
    error("Uso: cliente <ip> <user>\n");
    exit(1);
  }
  sscanf(argv[1], "%15s[0-9.]", ip);
  sscanf(argv[2], "%s128[0-9a-zA-Z._-]s", user);

  if (createsocketclient(&smtp, ip, 25) < 0) {
    error ("No se pudo establecer la conexion al puerto 25.\n");
    exit(1);
  }

  bzero ((char *)buffer, MAX_DATA_SIZE);
  if (readsocket(smtp, buffer, MAX_DATA_SIZE) < 0) {
    exit (-1);
  }

  if (strncmp(buffer, "220", 3) != 0) {
    fprintf (stderr, "Problemas con la comunicacion, el servidor respondio: %s\n", buffer);
    exit (-1);
  }

  /*
   * Transaccion del HELO
   */
  bzero ((char *)buffer, MAX_DATA_SIZE);
  strcpy (buffer, "HELO localhost.localdomain\n");
  if (writesocket(smtp, buffer, strlen(buffer))<0) {
    error ("No se pudo hablar con el otro extremo, no puedo continuar.\n");
    exit (-1);
  }
  bzero ((char *)buffer, MAX_DATA_SIZE);
  while(readsocket(smtp, buffer, MAX_DATA_SIZE) < 0) {
  }

  if (strncmp(buffer, "250", 3) != 0) {
    fprintf (stderr, "No se pudo hacer un HELO, el servidor respondio: %s\n", buffer);
    exit (-1);
  }
  
  /*
   * Seccion del VRFY
   */
  bzero ((char *)buffer, MAX_DATA_SIZE);
  sprintf (buffer, "VRFY %s\n", user);
  if (writesocket(smtp, buffer, strlen(buffer))<0) {
    error ("No se pudo hablar con el otro extremo, no puedo continuar.\n");
    exit (-1);
  }
  bzero ((char *)buffer, MAX_DATA_SIZE);
  while(readsocket(smtp, buffer, MAX_DATA_SIZE) < 0) {
  }
  
  if (strncmp(buffer, "252", 3) == 0) { /* Respondio con aceptado */

    /* Si no puede verificar avisa con un "Cannot VRFY user" */
    if (strncmp(buffer+10, "Cannot", 6) != 0) {
      printf ("OK %s\n", user);
    } else {
      printf ("??? %s\n", user);
      exit (-1);
    }
  } else {
    printf ("NOK %s\n", user);
    exit (-1);
  }

  close(smtp);
  exit(0);
}

/*
 * createsocketclient
 * Crea un socket para conectarse a un puerto en un socket
 * Recibe: apuntador a entero en el cual se guarda el socket, addr, una direccion ip
 * y  port, un puerto
 * Regresa: Nada
 */
int createsocketclient(int *sserv, char *addr, int port)
{
  int s_serv; //
  struct sockaddr_in serv_addr; // Informacion sobre la direccion del servidor
  struct hostent *server;

  /* Intentamos resolver la direccion del servidor,
     tambien se verifica que sea valida */
  if ((server = gethostbyname(addr)) == NULL) {
    error("La direccion ip no es valida.\n");
    return(-1);
  }
  if ((*sserv = socket(AF_INET, SOCK_STREAM, 0))< 0) {
    error("No fue posible crear el socket.");
    return(-1);
  }

  bzero((char *)&serv_addr, sizeof(serv_addr)); // Limpiamos la variable
  serv_addr.sin_family = AF_INET; //  IP v4

  bcopy((char *)server->h_addr, (char *)&serv_addr.sin_addr.s_addr,
        server->h_length);
  serv_addr.sin_port = htons(port);

  /* Intentamos la conexion con el servidor */
  if (connect(*sserv,(struct sockaddr *) &serv_addr,sizeof(serv_addr)) < 0) {
    error("Hubo problemas al tratar de hacer la conexion.\n");
    return(-1);
  }
  return (1);
}

/*
 * readsocket lee la informacion de un socket y la almacena en un buffer.
 * Recibe: socket donde se toman datos, buffer donde se guarda lo leido y
 * size_read, que indica el numero maximo de caracteres a tomar del socket.
 * Regresa: el numero de caracteres leidos o un valor negativo en caso de error.
 */
int readsocket(int socket, char *buffer, int size_read)
{
  int readRes;

  memset(buffer, '\0', size_read); // Limpiamos el buffer

  if((readRes = recv(socket, buffer, size_read, 0))<0)

    error("Error no es posible leer del socket");
  return(readRes);
}

/*
 * writesocket intenta mandar la informacion contenida en un buffer
 *  en el socket.
 * Recibe: el socket donde se escribe, el buffer donde la informacion
 * a enviar y la cantidad maxima de caracteres.
 * Regresa: el numero de caracteres enviados o un valor negativo en
 * caso de error.
 */
int writesocket(int socket, char *buffer, int size_write)
{
  int writeRes;

  if ((writeRes = send(socket, buffer, size_write, 0))<0)
      error("Error no es posible escribir en el socket");

  return(writeRes);
}

/*
 * Muestra el mensaje de error contenido en msg.
 */
void error(char *msg)
{
  fprintf(stderr, "%s", msg);
}
