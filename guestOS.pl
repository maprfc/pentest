#!/usr/bin/perl
##
## Mario Arturo Perez Rangel
## 17-03-2017
##
## Basado en el campo de TCP window scale, se intenta determinar
## el tipo de sistema operativo que corre el target.
##
## El programa hace uso de la bilbioteca Net::Pcap. En debian 8 es posible
## instalarla con: apt-get install libnet-pcap-perl, en fedora 25 con:
## dnf install perl-Net-Pcap
##
use warnings;
use strict;
use IO::Handle;
use IO::Socket::INET;
use IO::Interface qw (:flags);
use Net::Pcap;
use Thread;
use Getopt::Long;

my ($local_ip, $target_ip, $port);
my ($netmask, $error, $iface);
my ($capture, $filter, $filter_str, $pdump, $thr_pcap);
 
# UID y EUID
if ($< and $>) {
    print "Solo root puede correr este programa";
    exit (1);
}

GetOptions ("ip=s"   => \$target_ip,
            "port|p=s" => \$port);

if (!$target_ip and !$port) {
    print "Use: $0 --ip <ip> --port <port>\n";
    exit (1);
}

##################################################
##
## Preparacion del buffer de captura
#################################################

# Dispositivo por donde capturar paquetes
$iface = Net::Pcap::lookupdev(\$error);
if ($error) {
    print STDERR "Error: $error\n";
}

# Obtiene la ip y mascara de red de este equipo
get_local_ip_address($iface, \$local_ip, \$netmask);

# Prepara el filtro de captura (de tipo BPF usado por PCAP)
$filter_str = "(ip src $local_ip and ip dst $target_ip) or (ip src $target_ip and ip dst $local_ip)";

# Abrir la interface en modo promisco capturando a lo mas 3600
# bytes, con un timeout de 0 segundos (no timeout)
$capture = Net::Pcap::open_live ($iface, 3600, 1, 0, \$error);

if (!defined($capture)) {
    print STDERR "Error: $error\n";
    exit (1);
}

# Compila el filtro de captura y aplicalo para esta captura
if (Net::Pcap::compile ($capture, \$filter, $filter_str, 0, net_aton($netmask)) == -1) {
    print STDERR "Error:", Net::Pcap::geterr($capture) ,"\n";
}
Net::Pcap::setfilter ($capture, $filter);

$pdump = Net::Pcap::dump_open ($capture, "-");
if (!defined($pdump)) {
    print STDERR "Error:", Net::Pcap::geterr($capture) ,"\n";
}

##
## A continuacion separamaos la ejecucion de la escucha
## de la comunicacion entre el host y el target
$thr_pcap = Thread->new(\&process_pcap, \$capture);


# Conectarse al target para generar trafico
make_connection($target_ip, $port);
print "\n";

#Termina el proceso
$thr_pcap->join;
1;

##
## make_connection intenta abrir una conexion TCP al target
## a traves de un socket
## Recibe: la ip de destino ($dest) y el puerto remoto ($p)
## Regresa: nada
sub make_connection {
    my ($dest, $p) = @_;
    my $protocolo;

    $protocolo = getprotobyname('tcp');
    socket(SOCKET, PF_INET, SOCK_STREAM, $protocolo)
	or die "No se pudo crear el socket de comunicacion";
    connect (SOCKET, sockaddr_in($p, inet_aton($dest)))
	or die "No fue posible conectarse al target: ", $!, "\n";
    close (SOCKET);
}

##
## procesa_pcap escucha el trafico de la red y captura tramas
## acordes con el filtro de captura para procesarlas.
## Recibe: el buffer de captura
## Regresa: Nada
sub process_pcap {
    my $capt = shift @_;
    
    # Capturamos cuatro paquetes para analizar
    Net::Pcap::loop ($$capt, 4, \&process_packet, "root");

    Net::Pcap::close ($$capt);
}


##
## process_packet desmenuza los paquetes en busca del "windows scale"
## para determinar el tipo de sistema operativo corriendo en el target.
##
## Utiliza la funcion unpack, la cual interpreta una cadena de caracteres
## como secuencias de datos empacados con cierto formato. Como primer
## parametro unpack recibe  "C", "n" y otros parametros.
##
##  Con una "C" la cadena se interpreta como representacion de un valor
##  de tipo caracter sin signo (entero corto sin signo)
##  Con una "n" la cadena se interpreta como representacion de un valor
##  de tipo entero corto sin signo (2 bytes) en orden de "red".
##
## Recibe: informacion del usuario, hash con datos del paquete y el
##         paquete capturado.
## Regresa: nada
##
sub process_packet {
    my($user_data, $hdr, $pkt) = @_;
    my ($frame_type, $protocol);
    my ($ip_src, $ip_dst, $ip_tlen, $ip_hlen);
    my ($tcp_offset, $tcp_flags, $ws, $data, $data_len);

    # 12 bytes de las cabeceras de ethernet
    $frame_type = unpack("n", substr($pkt,12,2));

    $ip_hlen = unpack ("C", substr($pkt,14,1)); # Numero de palabras de 4 bytes
    $ip_hlen = ($ip_hlen & 0x0F) << 2 ;
    $protocol = unpack ("C", substr($pkt,23,1));
    # 14 bytes de cabeceras de ethernet + 12 bytes de cabeceras de ip
    $ip_src = join '.', unpack ("C4", substr ($pkt, 26, 4));
    $tcp_flags = unpack ("C", substr($pkt, 14+$ip_hlen+13, 1));

    # Es una trama de IP con un segmento de TCP proveninte del target 
    if (($frame_type == 0x800) &&
	($ip_src eq $target_ip) &&
	($protocol == 6)) {

	print "\nEl equipo ", $ip_src, " parace tener OS ";
	# Veamos la opcion windows scale en el paquete SYN-ACK de respuesta
	if (($tcp_flags & 0x02) && ($tcp_flags & 0x10)) {
	    $ws = unpack ("n",  substr($pkt, 14+$ip_hlen+14, 2));
	    if ($ws == 5792) {
		print "*nix/Linux .\n";
	    } elsif ($ws == 5840) {
		print "*nix/Linux 2.4/2.2";
	    } elsif ($ws == 16384) {
		print "OpenBSD/Aix 4.3/Windows";
	    } elsif ($ws == 8760) {
		print "OpenBSD";
	    } else {
		print "desconocido con Windows Scale: ", $ws, "\n";
	    }
	}
    }
}

# Obtiene la direccion ip de esta maquina
sub get_local_ip_address {
    my ($ifa, $la, $nma) = @_;
    my $socket = IO::Socket::INET->new(
        Proto       => 'udp',
        PeerAddr    => '198.41.0.4', # a.root-servers.net
        PeerPort    => '53', # DNS
    );

    # A side-effect of making a socket connection is that our IP address
    # is available from the 'sockhost' method
    $$la = $socket->sockhost;
    $$nma = $socket->if_netmask($iface);
}

##
## net_aton convierte una cadena con una direccion ip en un entero
## largo de 4 bytes correspondientes a dicha ip.
## Recibe: cadena con una direccion ip en formato con '.'.
## Regresa: el entero representando la ip
sub net_aton {
    my $ip = shift @_;
    my @oct;

    @oct = split /\./, $ip;
    return ($oct[0]*256**3 + $oct[1]*256*2 + $oct[2]*256 + $oct[3]);
}
