/**
 ** Mario Arturo Perez Rangel
 ** 16-03-2017
 **
 ** Implementacion de un ping sweep usando el protocolo ARP.
 **
 ** El programa obtiene de la interfaz de red, especificada por el usuario, el rango
 ** de direcciones ip en el segmento de red, basandose en la ip del equipo, la mascara de red
 ** y la direccion de broadcast. Si el usuario no dio la interfaz, el programa usa la primera
 ** distinta a loopback.
 **
 ** Implementa una estructura modelando un paquete de ethernet conteniend un entramado
 ** ARP. Con ella, hace un barrido de todas las ips y espera a recibir una respuesta.
 ** Si la respuesta tarda mas de MAX_RETRIES asume que el equipo remoto no esta en la red.
 **/
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <ifaddrs.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <net/if.h>
#include <netpacket/packet.h>
#include <net/ethernet.h>
#include "error.h"
#include "pingsw.h"


int main(int argc, char *argv[])
{
  ipaddr my_ip, first_ip, last_ip;
  char iface[IF_NAMESIZE];
  struct ifaddrs *addrs, *tmp;
  struct in_addr inaddr;
  
  if (getuid() && geteuid()) {
    error("Necesita ser super usuario para usar este programa");
    exit (-1);
  }
  if (argc >= 2) {           /* Usa la interfaz dad en linea de comandos */
    memcpy (iface, argv[1], IF_NAMESIZE);
  } else {                       /* Busca la primera distinta a loopback */
    getifaddrs(&addrs);
    tmp = addrs;
    while (tmp) {
      if (tmp->ifa_addr && tmp->ifa_addr->sa_family == AF_PACKET)
	if (strcmp(tmp->ifa_name, "lo") != 0) {
	  memcpy (iface, tmp->ifa_name, IF_NAMESIZE);
	  break;
	}
      tmp = tmp->ifa_next;
    }
    freeifaddrs(addrs);
  }

  /* Calcula la lista de hosts en la red */
  range_of_hosts (iface, &my_ip, &first_ip, &last_ip);

  for (;first_ip <= last_ip; first_ip++) {
    inaddr.s_addr = htonl(first_ip);
    if (send_arp_packet(iface, my_ip, first_ip) == 1) {
      fprintf (stderr, "%s\t UP\n", inet_ntoa(inaddr));
    } else {
      fprintf (stderr, "%s\t DOWN\n", inet_ntoa(inaddr));
    }
  }
}


/**
 ** send_arp_packet arma un paquete de ethernet conteniendo una trama de ARP y la envia
 ** a la interfaz de red. Espera MAX_RETRIES paquetes, cuando llega la respuesta de tipo
 ** ARP reply desde el host investigado se avisa.
 ** Recibe: el nombre de la interfaz de red, la ip del equipo y la ip del equipo remoto.
 ** Regresa: 1 si el equipo responde, -1 en caso contrario.
 **/
int send_arp_packet (char* iface, ipaddr ip_src, ipaddr ip_dst) {
  arp_pkt pkt;
  struct ifreq ifr;
  struct sockaddr_ll sa;
  int sock, arp, pkt_len, count;

  memcpy(ifr.ifr_name, iface, IF_NAMESIZE);

  /* Obtiene la direccion MAX del equipo local */
  if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0 ) {
    error("Error en el manejo de sockets");
    exit(1);
  }
  
  /* ioctl para obtener la direccion MAC */
  if( ioctl(sock, SIOCGIFHWADDR, &ifr, sizeof(ifr)) < 0 ) {
    error("Error con ioctl 1");
    close(sock);
    exit(1);
  }
  if( (arp = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ARP))) == -1 ) {
    error("ARP REQUEST Socket");
    close(sock);
    return (-1);
  }

  /**
   ** Armado del paquete ARP REQUEST
   **/

  /* Cabecera de la seccion de  ethernet */
  memset(pkt.mac_dst, 0xFF, (6 * sizeof(unsigned char)));
  memset(pkt.mac_src,   (ifr.ifr_hwaddr.sa_data[0]&0xFF), sizeof(unsigned char));
  memset(pkt.mac_src+1, (ifr.ifr_hwaddr.sa_data[1]&0xFF), sizeof(unsigned char));
  memset(pkt.mac_src+2, (ifr.ifr_hwaddr.sa_data[2]&0xFF), sizeof(unsigned char));
  memset(pkt.mac_src+3, (ifr.ifr_hwaddr.sa_data[3]&0xFF), sizeof(unsigned char));
  memset(pkt.mac_src+4, (ifr.ifr_hwaddr.sa_data[4]&0xFF), sizeof(unsigned char));
  memset(pkt.mac_src+5, (ifr.ifr_hwaddr.sa_data[5]&0xFF), sizeof(unsigned char));
  pkt.frame_type = htons(0x0806); /* Dentro viene un paquete ARP */

  /* Cabeceras de la seccion de ARP */
  pkt.hw_type = htons(0x0001);    /* Interfaz ethernet */
  pkt.proto_type = htons(0x0800); /* Indica manejo de direcciones de tipo IP */
  pkt.hw_size = 0x06;             /* Longitud de las direcciones MAC (en bytes) */
  pkt.proto_size = 0x04;          /* Longitud de las direcciones IP (en bytes) */
  pkt.opcode = htons(0x0001);     /* ARP request (2 si fuera ARP REPLY)*/
  memcpy(pkt.mac_sender, pkt.mac_src, (6 * sizeof(unsigned char)));
  pkt.ip_sender = htonl(ip_src);
  memset(pkt.mac_target, 0 , (6 * sizeof(unsigned char)));
  pkt.ip_target = htonl(ip_dst);
  // Padding
  memset(pkt.padding, 0 , 18 * sizeof(unsigned char));

  /* El indice en el sistema local de la interfaz de red */
  if(ioctl(sock, SIOCGIFINDEX, &ifr, sizeof(ifr)) < 0 ) {
    error("IOCTL");
    close(arp);
    close(sock);
    return (-1);
  }

  /* Indicamos que se trata de un paquete ethernet */ 
  sa.sll_family = AF_PACKET;
  sa.sll_ifindex = ifr.ifr_ifindex;
  sa.sll_protocol = htons(ETH_P_ARP);

  /* Envia el paquete */
  if(sendto(arp, &pkt, sizeof(pkt), 0, (struct sockaddr *)&sa, sizeof(sa)) < 0 ) {
    error("sendto 1\n");
    close(arp);
    close(sock);
    return (-1);
  }

  /* Esperamos por una respuesta */
  for (count=0; count<MAX_RETRIES;count++) {
    if(recv(arp, &pkt, sizeof(pkt),0) < 0 ) {
      error("sendto 2\n");
      close(arp);
      close(sock);
      return (-1);
    }
    if ((ntohs(pkt.frame_type) == 0x0806)
	&&  (ntohs(pkt.opcode) == 2)
	&& (pkt.ip_sender == htonl(ip_dst))) { /* Se recibio una respuesta */
      return (1);
    }
  }
  return (-1); /* No hubo respuesta */
}

/**
 ** range_of_hosts: basado en la direccion ip del equipo encuentra el rango de ips haciendo
 ** operaciones de bits entre la ip y la mascara.
 ** Recibe: El nombre de la interfaz, y tres apuntadores donde guarda la ip del equipo,
 ** y la primer y ultima ip del segmento, en ese orden.
 ** Regresa: nada.
 **/
void range_of_hosts (char *iface, ipaddr* myip,
		     ipaddr* fip, ipaddr* lip) {
  int sock;
  unsigned long nmask, bcast;
  struct ifreq ifr;
  struct sockaddr_in *sin;

  memcpy(ifr.ifr_name, iface, IF_NAMESIZE);
  if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0 ) {
    error("Error en el manejo de sockets");
    exit(1);
  }
  
  /* ioctl para obtener la direccion ip */
  if( ioctl(sock, SIOCGIFADDR, &ifr, sizeof(ifr)) < 0 ) {
    error("Error con ioctl 1");
    close(sock);
    exit(1);
  }
  /* obtener la ip */
  sin = (struct sockaddr_in *)&ifr.ifr_addr;
  *myip = ntohl(sin->sin_addr.s_addr);

  /* ioctl para obtener la mascara de red */
  if( ioctl(sock, SIOCGIFNETMASK, &ifr, sizeof(ifr)) < 0 ) {
    error("Error con ioctl");
    close(sock);
    exit(1);
  }
  /* obtener la mascara */
  sin = (struct sockaddr_in *)&ifr.ifr_netmask;
  nmask = ntohl(sin->sin_addr.s_addr);

  /* ioctl para obtener la direccion de broadcast */
  if( ioctl(sock, SIOCGIFBRDADDR, &ifr, sizeof(ifr)) < 0 ) {
    error("Error con ioctl");
    close(sock);
    exit(1);
  }
  /* obtener la mascara */
  sin = (struct sockaddr_in *)&ifr.ifr_broadaddr;
  bcast= ntohl(sin->sin_addr.s_addr);

  *fip = (*myip) & nmask; /* Primer ip del segmento */
  (*fip)++;
  *lip = --bcast;         /* Ultima ip del segmento */

  close (sock);
}
